// Global variables
var dateMask = "dd/mm/yyyy";
var __nukeLocker = false;

// A collection of every component that has an error
var nukeErrors = [];
var __nukeFormState = false;

// Makes a random string of the specified size
// length: The size of the string to make
function makeRandomString(length) {
    var text = "";
    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    for (var i = 0; i < length; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}

var Async = function (func, p1, p2, p3, p4, p5, p6, p7, p8) {
    var as = {};
    as.code = "";
    as.func = func;
    as.onSuccess = function (data) {
        this.data = data;
        for (var i = 0; i < as.queue.length; i++) {
            as.queue[i](data, as);
        }
    }

    as.get = function () {
        return data;
    }
    as.queue = [];
    as.func(as, p1, p2, p3, p4, p5, p6, p7, p8);
    return as;
}

function async(func, p1, p2, p3, p4, p5, p6, p7, p8) {
    return new Async(func, p1, p2, p3, p4, p5, p6, p7, p8);
}

// Executes an Ajax Get using JQuery (expects default ResponseObject)
// url: The url to post
// data: The data to post
// onSuccess: Function to be called if sucess is achieved
// onError: Function to be called if shit happens
function nukeGet(url, onSuccess, onError) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url);
    xhr.onload = function(result) {
        if (xhr.status === 200) {
            if (!isnull(onSuccess)) {
                onSuccess(xhr.response);
            }
        }
        else {
            if (!isnull(onError)) {
                onError(xhr.response);
            }
        }
    };
    xhr.send();
}

function aGet(asyncObj, url, onError) {
    return nukeGet(url, asyncObj.onSuccess, onError);
}

// Checks if an object is null, undefined, empty ("") or NaN
function isnull(obj) {
    return obj == null || obj == undefined || obj === "";
}

// Replaces a character at the specified position by the specified string/char
// index: The index of the character to remove and start replacting
// character: The character/string to replace at the index
String.prototype.replaceAt = function (index, character) {
    return this.substr(0, index) + character + this.substr(index + character.length);
}

// Converts a String to a Boolean correctly
// string: The string to convert to boolean. Acceped values:
//          true, yes, 1 for true
//          false, no, 0 for false
// Trivia: JavaScript default conversion converts 'anything' that isn't empty to true, 
// so: var str = (Boolean)'false'; gets the result 'true';
function nukeStringToBoolean(string) {
    if (typeof string === 'string' || string instanceof String) {
        switch (string.toLowerCase().trim()) {
            case "true": case "yes": case "1": return true;
            case "false": case "no": case "0": case null: return false;
            default: return Boolean(string);
        }
    }
    return string;
}

// Validates if the provided string is an email
// email: String to test to see if it's an email
function nukeValidateEmail(email) {
    var regex = /^([a-zA-Z0-9_.+-])+\@(([a-zA-Z0-9-])+\.)+([a-zA-Z0-9]{2,4})+$/;
    return regex.test(email);
}

// Gets all the URL variables in an array
function nukeGetUrlVars() {
    var vars = [], hash;
    var hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&');
    for (var i = 0; i < hashes.length; i++) {
        hash = hashes[i].split('=');
        vars.push(hash[0]);
        vars[hash[0]] = hash[1];
    }
    return vars;
}

// Formats a date to a specific format. Parses the date if it's not a Date object
// date: The date object/string to format
// format: The pattern to format the date with
function nukeFormatDate(date, format) {
    var dat = date;
    if (!(date instanceof Date)) {
        // parse
        dat = new Date(date);
    }

    return dat.format(format);
}

// Parses a date with brazilian format (dd/MM/YYYY)
// date: The date to format
function nukeParseDate(date) {
    var split = date.split('/');

    var day = split[0];
    var month = split[1];
    var year = split[2];

    return new Date(year, month, day);
}
// Removes all repeated characters on a string
// str: The string to check for repeated characters
function nukeStringRemoveRepeatedChars(str) {
    var toRet = '';
    for (var i = 0; i < str.length; i++) {
        var ch = str[i];
        if (toRet.indexOf(ch) == -1) {
            toRet += ch;
        }
    }
    return toRet;
}
// Removes all instances of characters on the designated pattern.
// Though the pattern is supposed to be a string, the checking is made on specific characters
// str: The string to modify
// pattern: The pattern to remove characters from the str
function nukeStringRemoveAllInstancesOff(str, pattern) {
    var toRet = '';
    for (var i = 0; i < str.length; i++) {
        var ch = str[i];
        if (pattern.indexOf(ch) == -1) {
            toRet += ch;
        }
    }
    return toRet;
}
// Removes a mask from the masked string
// str: The string to remove the mask from
// mask: The mask to remove from the string
//
// Trivia: Doesn't work with characters for now
function nukeRemoveMask(str, mask) {
    var digits = mask.replace(/\d+/g, '')
    var single = nukeStringRemoveRepeatedChars(digits);
    return nukeStringRemoveAllInstancesOff(str, single);
}